# Ethics Application System Backend applications Module
The applications module provides the backend functionality for applications management. It allows for applications to be defined,
created, submitted by applicants and the review of applications by the ethics committee. It provides the main functionality
for applications as outlined in the requirements.

## Endpoints
All endpoints in this module start with the prefix `/api/applications`. If there is a [blank] endpoint entry, it means there
is no extra path elements after the prefix

| Endpoint   | Method | Description                                                                                                                  |
|------------|--------|------------------------------------------------------------------------------------------------------------------------------|
| /templates | GET    | Retrieve all the application templates loaded into the system                                                                |
| /template  | GET    | Get a specific application template using id request parameter                                                               |
| [blank]    | GET    | Retrieve an application using either the database ID (dbId parameter) or the id generated by the /id endpoint (id parameter) |
| /user      | GET    | Retrieve all applications for a given user. It can either be a list of applications the user can view or they are assigned to if a committee member |
| /draft     | POST   | Create a draft application using the generated ID                                                                            |
|            | PUT    | Update the draft application that is being created                                                                           |
| /submit    | POST   | Submit the draft application that is being created to the ethics committee and set it to a Submitted status                  |
| /resubmit  | POST   | Allows an admin/chair to accept an application that has been re-submitted back after being referred and assign committee members to it |
| /assign    | POST   | Allows an admin/chair to assign committee members to an application
| /unassign/{username} | POST | Allows the committee member with username to be unassigned from the application  |
| /review    | POST   | Set a submitted application to in review or an application in review to reviewed                                             |
|            | PUT    | Allows a reviewer to add comments to an application in review |
| /comment  | PATCH    | Allows a comment to be updated/deleted (a top-level comment, not a sub-comment) on an application
| /review/finish | POST | Allows an individual committee member mark that their review has completed |
| /approve   | POST   | Approve/Reject an application that has been reviewed by committee members                                                    |
| /refer     | POST   | Refer a reviewed application back to the applicant for more information                                                      |
| /referred | PUT    | Allows the update of the answers given on the referred application   |
| /search   | GET    | Allows the searching of application using a query language in the URL query string |
| /answers | PATCH | Allows the patching/updating of specific answers on the application |

## Configuration
The module provides 1 main property in the [application.ethics.properties](src/main/resources/applications.ethics.properties) file:
```
applications.templates.filePaths[0]=classpath:expedited.form.json
applications.templates.filePaths[1]=classpath:full.form.json
```
It is an array of application templates to load (see the Application Templates section). The files can be loaded from classpath
with the classpath: prefix or without the prefix, it can be a filepath to a file on the server's filesystem.

## Application Templates
The structure/composition of an application in the system is defined as a JSON-formatted file called an **application template**.
They allow the definition of an application in the format of JSON. The JSON is then mapped to Java components as defined in
the [components](src/main/java/ie/ul/ethics/scieng/applications/templates/components) package. The current existing templates
are as follows:
* [Expedited Application Form](src/main/resources/expedited.form.json)
* [Full Application Form](src/main/resources/full.form.json)

### Defining a new component
To define a new component, you have to follow this process:
1. Decide on a label for the component, for example `example-component`. This will be the value contained within the `type`
    field of each object. This is what is used to convert the JSON object to a component. Then define an enum value in the
   [ComponentType.java](src/main/java/ie/ul/ethics/scieng/applications/templates/components/ComponentType.java) file, like so:
    `EXAMPLE_COMPONENT("example-component")`, with the string in brackets being the value contained in the `type` field
2. You then need to define a subclass of either [SimpleComponent.java](src/main/java/ie/ul/ethics/scieng/applications/templates/components/SimpleComponent.java)
   or [CompositeComponent.java](src/main/java/ie/ul/ethics/scieng/applications/templates/components/CompositeComponent.java).
   If your component is a question, or a piece of text, use SimpleComponent, if it holds other components, like a section, or container,
   use CompositeComponent. The type property passed into super constructor should be the enum value you defined in step 1
3. You then need to define an implementation of [ComponentConverter.java](src/main/java/ie/ul/ethics/scieng/applications/templates/converters/ComponentConverter.java)
   which will convert the component defined. The concrete implementation should be annotated with the [Converter.java](src/main/java/ie/ul/ethics/scieng/applications/templates/converters/Converter.java)
   annotation with the enum value defined above. Example:
```java
@Converter(ComponentType.EXAMPLE_COMPONENT)
public class ExampleComponentConverter implements ComponentConverter {
    @Override
    public void validate(Map<String, Object> map) throws ApplicationParseException {
        // validate that the map contains all the required keys and valid values
        // If not valid, throw an ApplicationParseException
    }
    
    @Override
    public ApplicationComponent convert(Map<String, Object> map) throws ApplicationParseException {
        // should call this.validate(map) here
        // convert the map to the appropriate ApplicationComponent and return it
    }
}
```
The class needs to be within the same package as the other converters and the other annotation. After the converter is annotated,
it can be retrieved using `Converters.getConverter("example-component")`. Note that the string passed in is the label from the enum
value and the type used in JSON
4. To use the new component, in the JSON file, when creating an object, do the following:
```json
{
  "type": "example-component",
  ... other properties go here
}
```

**Note**: The front-end should have corresponding components